class N{constructor(e,r){this.operator=e,this.value=r,Object.defineProperty(this,"t",{writable:!0})}get notes(){return this.t}addNote(e){this.t=this.t||[],this.t.push(e)}}let g=class extends N{};class f extends g{constructor(e,r){if(!Array.isArray(r))throw new Error(`"${e}" operator expects to receive an array of conditions`);super(e,r)}}const p="__itself__";let d=class extends N{constructor(e,r,n){super(e,n),this.field=r}};const q=new g("__null__",null),y=Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);function H(t,e){return e instanceof f&&e.operator===t}function C(t,e){return e.length===1?e[0]:new f(t,function r(n,o,s){const a=s||[];for(let i=0,u=o.length;i<u;i++){const c=o[i];H(n,c)?r(n,c.value,a):a.push(c)}return a}(t,e))}const K=t=>t,F=()=>Object.create(null),P=Object.defineProperty(F(),"__@type@__",{value:"ignore value"});function L(t,e,r=!1){if(!t||t&&t.constructor!==Object)return!1;for(const n in t)if(y(t,n)&&y(e,n)&&(!r||t[n]!==P))return!0;return!1}function Q(t){const e=[];for(const r in t)y(t,r)&&t[r]!==P&&e.push(r);return e}function h(t,e){e!==q&&t.push(e)}const I=t=>C("and",t),z={compound(t,e,r){const n=(Array.isArray(e)?e:[e]).map(o=>r.parse(o));return new f(t.name,n)},field:(t,e,r)=>new d(t.name,r.field,e),document:(t,e)=>new g(t.name,e)};let W=class{constructor(e,r=F()){this.o=void 0,this.s=void 0,this.i=void 0,this.u=void 0,this.h=void 0,this.parse=this.parse.bind(this),this.u={operatorToConditionName:r.operatorToConditionName||K,defaultOperatorName:r.defaultOperatorName||"eq",mergeFinalConditions:r.mergeFinalConditions||I},this.o=Object.keys(e).reduce((n,o)=>(n[o]=Object.assign({name:this.u.operatorToConditionName(o)},e[o]),n),{}),this.s=Object.assign({},r.fieldContext,{field:"",query:{},parse:this.parse,hasOperators:n=>L(n,this.o,r.useIgnoreValue)}),this.i=Object.assign({},r.documentContext,{parse:this.parse,query:{}}),this.h=r.useIgnoreValue?Q:Object.keys}setParse(e){this.parse=e,this.s.parse=e,this.i.parse=e}parseField(e,r,n,o){const s=this.o[r];if(!s)throw new Error(`Unsupported operator "${r}"`);if(s.type!=="field")throw new Error(`Unexpected ${s.type} operator "${r}" at field level`);return this.s.field=e,this.s.query=o,this.parseInstruction(s,n,this.s)}parseInstruction(e,r,n){return typeof e.validate=="function"&&e.validate(e,r),(e.parse||z[e.type])(e,r,n)}parseFieldOperators(e,r){const n=[],o=this.h(r);for(let s=0,a=o.length;s<a;s++){const i=o[s];if(!this.o[i])throw new Error(`Field query for "${e}" may contain only operators or a plain object as a value`);h(n,this.parseField(e,i,r[i],r))}return n}parse(e){const r=[],n=this.h(e);this.i.query=e;for(let o=0,s=n.length;o<s;o++){const a=n[o],i=e[a],u=this.o[a];if(u){if(u.type!=="document"&&u.type!=="compound")throw new Error(`Cannot use parsing instruction for operator "${a}" in "document" context as it is supposed to be used in  "${u.type}" context`);h(r,this.parseInstruction(u,i,this.i))}else this.s.hasOperators(i)?r.push(...this.parseFieldOperators(a,i)):h(r,this.parseField(a,this.u.defaultOperatorName,i,e))}return this.u.mergeFinalConditions(r)}};function $(t,e){const r=t[e];if(typeof r!="function")throw new Error(`Unable to interpret "${e}" condition. Did you forget to register interpreter for it?`);return r}function X(t){return t.operator}function Y(t,e){const r=e,n=r&&r.getInterpreterName||X;let o;switch(r?r.numberOfArguments:0){case 1:o=a=>{const i=n(a,r);return $(t,i)(a,s)};break;case 3:o=(a,i,u)=>{const c=n(a,r);return $(t,c)(a,i,u,s)};break;default:o=(a,i)=>{const u=n(a,r);return $(t,u)(a,i,s)}}const s=Object.assign({},r,{interpret:o});return s.interpret}function Z(t,e){return(r,...n)=>{const o=t(r,...n),s=e.bind(null,o);return s.ast=o,s}}function k(t,e){if(!Array.isArray(e))throw new Error(`"${t.name}" expects value to be an array`)}function R(t,e){if(k(t,e),!e.length)throw new Error(`"${t.name}" expects to have at least one element in array`)}const v=t=>(e,r)=>{if(typeof r!==t)throw new Error(`"${e.name}" expects value to be a "${t}"`)},T={type:"compound",validate:R,parse(t,e,{parse:r}){const n=e.map(o=>r(o));return C(t.name,n)}},ee=T,te={type:"compound",validate:R},re={type:"field",validate(t,e){if(!(e&&(e instanceof RegExp||e.constructor===Object)))throw new Error(`"${t.name}" expects to receive either regular expression or object of field operators`)},parse(t,e,r){const n=e instanceof RegExp?new d("regex",r.field,e):r.parse(e,r);return new f(t.name,[n])}},ne={type:"field",validate(t,e){if(!e||e.constructor!==Object)throw new Error(`"${t.name}" expects to receive an object with nested query or field level operators`)},parse(t,e,{parse:r,field:n,hasOperators:o}){const s=o(e)?r(e,{field:p}):r(e);return new d(t.name,n,s)}},oe={type:"field",validate:v("number")},w={type:"field",validate:k},se=w,ae=w,ie={type:"field",validate(t,e){if(!Array.isArray(e)||e.length!==2)throw new Error(`"${t.name}" expects an array with 2 numeric elements`)}},ue={type:"field",validate:v("boolean")},U={type:"field",validate:function(t,e){if(!(typeof e=="string"||typeof e=="number"||e instanceof Date))throw new Error(`"${t.name}" expects value to be comparable (i.e., string, number or date)`)}},b=U,ce=b,le=b,D={type:"field"},pe=D,fe={type:"field",validate(t,e){if(!(e instanceof RegExp)&&typeof e!="string")throw new Error(`"${t.name}" expects value to be a regular expression or a string that represents regular expression`)},parse(t,e,r){const n=typeof e=="string"?new RegExp(e,r.query.$options||""):e;return new d(t.name,r.field,n)}},de={type:"field",parse:()=>q},he={type:"document",validate:v("function")};var $e=Object.freeze({__proto__:null,$and:T,$or:ee,$nor:te,$not:re,$elemMatch:ne,$size:oe,$in:w,$nin:se,$all:ae,$mod:ie,$exists:ue,$gte:U,$gt:b,$lt:ce,$lte:le,$eq:D,$ne:pe,$regex:fe,$options:de,$where:he});class ye extends W{constructor(e){super(e,{defaultOperatorName:"$eq",operatorToConditionName:r=>r.slice(1)})}parse(e,r){return r&&r.field?I(this.parseFieldOperators(r.field,e)):super.parse(e)}}const m=$e;function O(t,e,r){for(let n=0,o=t.length;n<o;n++)if(r(t[n],e)===0)return!0;return!1}function x(t,e){return Array.isArray(t)&&Number.isNaN(Number(e))}function _(t,e,r){if(!x(t,e))return r(t,e);let n=[];for(let o=0;o<t.length;o++){const s=r(t[o],e);s!==void 0&&(n=n.concat(s))}return n}function l(t){return(e,r,n)=>{const o=n.get(r,e.field);return Array.isArray(o)?o.some(s=>t(e,s,n)):t(e,o,n)}}const me=(t,e)=>t[e];function M(t,e,r){const n=e.lastIndexOf(".");return n===-1?[t,e]:[r(t,e.slice(0,n)),e.slice(n+1)]}function ge(t,e,r=me){if(e===p)return t;if(!t)throw new Error(`Unable to get field "${e}" out of ${String(t)}.`);return function(n,o,s){if(o.indexOf(".")===-1)return _(n,o,s);const a=o.split(".");let i=n;for(let u=0,c=a.length;u<c;u++)if(i=_(i,a[u],s),!i||typeof i!="object")return i;return i}(t,e,r)}function S(t,e){return t===e?0:t>e?1:-1}function B(t,e={}){return Y(t,Object.assign({get:ge,compare:S},e))}const J=(t,e,{interpret:r})=>t.value.some(n=>r(n,e)),ve=(t,e,r)=>!J(t,e,r),we=(t,e,{interpret:r})=>t.value.every(n=>r(n,e)),be=(t,e,{interpret:r})=>!r(t.value[0],e),V=(t,e,{compare:r,get:n})=>{const o=n(e,t.field);return Array.isArray(o)&&!Array.isArray(t.value)?O(o,t.value,r):r(o,t.value)===0},Oe=(t,e,r)=>!V(t,e,r),xe=l((t,e,r)=>{const n=r.compare(e,t.value);return n===0||n===-1}),je=l((t,e,r)=>r.compare(e,t.value)===-1),Ae=l((t,e,r)=>r.compare(e,t.value)===1),_e=l((t,e,r)=>{const n=r.compare(e,t.value);return n===0||n===1}),Ee=(t,e,{get:r})=>{if(t.field===p)return e!==void 0;const[n,o]=M(e,t.field,r),s=a=>a==null?!!a===t.value:a.hasOwnProperty(o)===t.value;return x(n,o)?n.some(s):s(n)},Ne=l((t,e)=>typeof e=="number"&&e%t.value[0]===t.value[1]),qe=(t,e,{get:r})=>{const[n,o]=M(e,t.field,r),s=a=>{const i=r(a,o);return Array.isArray(i)&&i.length===t.value};return t.field!==p&&x(n,o)?n.some(s):s(n)},Ce=l((t,e)=>typeof e=="string"&&t.value.test(e)),j=l((t,e,{compare:r})=>O(t.value,e,r)),Fe=(t,e,r)=>!j(t,e,r),Pe=(t,e,{compare:r,get:n})=>{const o=n(e,t.field);return Array.isArray(o)&&t.value.every(s=>O(o,s,r))},Ie=(t,e,{interpret:r,get:n})=>{const o=n(e,t.field);return Array.isArray(o)&&o.some(s=>r(t.value,s))},ze=(t,e)=>t.value.call(e);var ke=Object.freeze({__proto__:null,or:J,nor:ve,and:we,not:be,eq:V,ne:Oe,lte:xe,lt:je,gt:Ae,gte:_e,exists:Ee,mod:Ne,size:qe,regex:Ce,within:j,nin:Fe,all:Pe,elemMatch:Ie,where:ze});const A=Object.assign({},ke,{in:j});B(A);function E(t){return t===null||typeof t!="object"?t:t instanceof Date?t.getTime():t&&typeof t.toJSON=="function"?t.toJSON():t}const Re=(t,e)=>S(E(t),E(e));function G(t,e,r){const n=new ye(t),o=B(e,Object.assign({compare:Re},r));if(r&&r.forPrimitives){const s={field:p},a=n.parse;n.setParse(i=>a(i,s))}return Z(n.parse,o)}G(m,A);G(["$and","$or"].reduce((t,e)=>(t[e]=Object.assign({},t[e],{type:"field"}),t),Object.assign({},m,{$nor:Object.assign({},m.$nor,{type:"field",parse:z.compound})})),A,{forPrimitives:!0});export{ne as $,Oe as A,ce as E,j as N,D as O,pe as R,fe as _,we as a,b,Ee as c,Ce as d,qe as e,Pe as f,U as g,Fe as h,_e as i,le as j,Ae as k,xe as l,ue as m,je as n,V as o,G as p,de as q,ae as v,oe as w,se as x,w as y,Ie as z};
